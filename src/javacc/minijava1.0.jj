PARSER_BEGIN(JVMMain)

package mjc;

import java.io.*;
import syntaxtree.*;
import symboltree.*;
import visitor.*;
import error.*;

import java.math.BigInteger;
import java.util.ArrayList;
import java.io.PrintStream;
import java.io.File;

/**
 * Grammar to parse MiniJava language 
 * @author Christopher Teljstedt and Carl Eriksson 
 */
public class JVMMain
{

public final static boolean VERBOSE = true;

public JVMMain (String fileName){
	this(System.in);
    try { ReInit(new FileInputStream(new File(fileName))); }
    catch(Exception e) { e.printStackTrace(); }
}

public static void main(String args[]) {
	JVMMain parser = null;
  Program program;
  SyntaxTreePrinter stp;
  SymbolTableBuilderVisitor stb;
  TypeDepthFirstVisitor tdfv;

	if (args.length == 0) {
		System.out.println("MiniJavac 1.0:  Reading from standard input . . .");
		parser = new JVMMain(System.in);
	} 
  else if (args.length == 1) {
		System.out.println("MiniJavac 1.0:  Reading from file " + args[0] + " . . .");
		try {
			parser = new JVMMain(new java.io.FileInputStream(args[0]));
		} catch (java.io.FileNotFoundException e) {
			System.out.println("MiniJavac 1.0: File " + args[0] + " not found.");
			System.exit(1);
		}
  } 
  else if (args.length == 2){
    System.out.println("MiniJavac 1.0:  Reading from file " + args[0] + " . . .");
    try {
      parser = new JVMMain(new java.io.FileInputStream(args[0]));
    } catch (java.io.FileNotFoundException e) {
      System.out.println("MiniJavac 1.0: File " + args[0] + " not found.");
      System.exit(1);
    }  
	}
  else {
		System.out.println("MiniJavac 1.0:  Usage is one of:");
		System.out.println("         java JavaParser < inputfile");
		System.out.println("OR");
		System.out.println("         java JavaParser inputfile");
		System.exit(0);
	}
	try {
		program = parser.Program();

    
    // VERBOSE: Print abstract syntax tree 
    if(VERBOSE) {
      stp = new SyntaxTreePrinter(System.out);
      stp.visit(program);
      System.out.println();
    }
   
    //Symbol table
    stb = new SymbolTableBuilderVisitor();
    stb.visit(program);

    // VERBOSE: Output symbol table
    if(VERBOSE) {
      Table st = stb.scopeLookupTable.get(program);
      System.out.println(st.toString(0));
    }
    
    //Type checking.
    tdfv = new TypeDepthFirstVisitor();
    tdfv.scopeLookupTable = stb.scopeLookupTable;
    tdfv.visit(program);


    for(String className : stb.classes){
      new File(className+".j").createNewFile(); 
    }
    if(stb.hasErrors()){
      for(CompilerError err : stb.getErrors()){
          System.err.println(err);
      }
      throw new Exception("Symbol table error");
    }

    if(tdfv.hasErrors()){
       for(CompilerError err : tdfv.getErrors()){
          System.err.println(err);
       }
       throw new Exception("Type checker error");
    }

		System.out.println("MiniJavac 1.0: Java program parsed successfully.");
	} catch (Exception e) {
		System.out.println(e.getMessage());
		System.out.println("MiniJavac 1.0: Encountered errors during parse.");
    System.exit(1);
	}
  System.exit(0);
}
}
PARSER_END(JVMMain)

SKIP: /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN:  /* RESERVED WORDS AND LITERALS */
{
  < BOOLEAN: "boolean" >
| < CLASS: "class" >
| < ELSE: "else" >
| < FALSE: "false" >
| < IF: "if" >
| < INT: "int" >
| < LONG: "long" >
| < NEW: "new" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < STATIC: "static" >
| < THIS: "this" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
| < LENGTH: "length" >
| < EXTENDS: "extends" >
| < STRING: "String" >
| < SYSOUT_PRINTLN : "System.out.println" >
}

TOKEN: /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < NOT: "!" >
}


TOKEN: /* LITERALS */
{
  < INTEGER_LITERAL: ( ["0"] | ["1"-"9"](["0"-"9"])*) >
|
  < LONG_LITERAL: "0" | ["1"-"9"](["0"-"9"])* ["l", "L"] >
}


TOKEN: /* IDENTIFIER LITTERAL */
{
  < IDENTIFIER: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "0"-"9", "_"])* >
}

TOKEN: /* OPERATORS */
{
  < ASSIGN: "=" >
| < LT: "<" >
// | < GT: ">" >
| < EQ: "==" > /* Bonus 1p */
// | < LE: "<=" > /* Bonus 1p */
// | < GE: ">=" > /* Bonus 1p */
| < NE: "!=" > /* Bonus 1p */
| < SC_OR: "||" > /* Bonus 2p */
| < SC_AND: "&&" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/**********************************************
 * THE MINI JAVA LANGUAGE GRAMMAR STARTS HERE *
 **********************************************/
/*
 * Program structuring syntax follows.
 */

/* Top level production */
Program Program():
{ MainClass mc; ClassDeclList cdl; }
{
  /* The first class must be the main class */
  mc=MainClass()

  /* Then zero or more other class declarations */
  cdl = ClassDeclList() 

  /* And nothing else can be in the file */
  < EOF >
  { return new Program(mc, cdl); }
}

ClassDeclList ClassDeclList():
{ ClassDecl c; ClassDeclList cdl = new ClassDeclList(); }
{
  (
      LOOKAHEAD(3)
      c = ClassDecl()
      { cdl.addElement(c); } 
    |
      c = ClassDeclExtends()
      { cdl.addElement(c); }
  )*
  { return cdl; }
}

MainClass MainClass():
{ Token t; Token main; Identifier id1, id2; VarDecl v; Statement stmt; VarDeclList vdl = new VarDeclList(); StatementList sl = new StatementList(); }
{
  <CLASS>
  t = <IDENTIFIER> { id1 = new Identifier(t.image, t.endLine, t.endColumn); }
  <LBRACE>
      <PUBLIC> <STATIC> <VOID> main = <IDENTIFIER> <LPAREN> <STRING> <LBRACKET> <RBRACKET> t = <IDENTIFIER> { id2 = new Identifier(t.image, t.endLine, t.endColumn); } <RPAREN>
      <LBRACE> //Block
      ( LOOKAHEAD( Type() <IDENTIFIER> ) v = VarDecl() { vdl.addElement(v); } )* 
      ( stmt = Stmt() { sl.addElement(stmt); } )* 
      <RBRACE>
  <RBRACE>
  { 
    if(!main.image.equals("main")){
      System.exit(1);
    };
  }
  { return new MainClass(id1, id2, vdl, sl, main.endLine, main.endColumn); }
}

ClassDeclExtends ClassDeclExtends():
{
  Token t; Identifier id, ide; VarDecl v; MethodDecl m; VarDeclList vl = new VarDeclList(); MethodDeclList ml = new MethodDeclList();
}
{
  <CLASS> t=<IDENTIFIER>  { id=new Identifier(t.image, t.endLine, t.endColumn); } <EXTENDS> t = <IDENTIFIER> { ide = new Identifier(t.image, t.endLine, t.endColumn); } 
  <LBRACE> //Block
       ( LOOKAHEAD(2) v = VarDecl() {vl.addElement(v); } )* ( m = MethodDecl() { ml.addElement(m); } )* 
  <RBRACE>
  { return new ClassDeclExtends(id, ide, vl, ml, t.endLine, t.endColumn); }
}


ClassDeclSimple ClassDecl():
{
  Token t; Identifier id, ide; VarDecl v; MethodDecl m; VarDeclList vl = new VarDeclList(); MethodDeclList ml = new MethodDeclList();
}
{
  <CLASS> t=<IDENTIFIER> { id = new Identifier(t.image, t.endLine, t.endColumn); }
  <LBRACE> //Block
       ( LOOKAHEAD(2) v = VarDecl() {vl.addElement(v); } )* ( m = MethodDecl() { ml.addElement(m); } )* 
  <RBRACE>
  { return new ClassDeclSimple(id, vl, ml, t.endLine, t.endColumn); }
}

/* Variable declaration */
VarDecl VarDecl() :
{ Token t; Type type; Identifier id; }
{
  ( type=Type() t = <IDENTIFIER> { id = new Identifier(t.image, t.endLine, t.endColumn); } <SEMICOLON> )  { return new VarDecl(type, id); }
}

MethodDecl MethodDecl():
{ Exp e; Token t; Type type; Identifier id;  VarDecl v; Statement s; FormalList fl = new FormalList(); VarDeclList vl = new VarDeclList(); StatementList sl = new StatementList(); }
{
  <PUBLIC> type = Type() ( t = <IDENTIFIER> { id = new Identifier(t.image, t.endLine, t.endColumn); } ) <LPAREN> [ fl = FormalList() ] <RPAREN>
  <LBRACE> 
    ( LOOKAHEAD(2) v = VarDecl() { vl.addElement(v); } )* 
    ( s = Stmt() { sl.addElement(s); } )*  
    <RETURN> e = Exp() <SEMICOLON>
  <RBRACE>
  { return new MethodDecl(type, id, fl, vl, sl, e, t.endLine, t.endColumn); }
}

FormalList FormalList():
{ Token t; Type type; Identifier id; Formal f; FormalList fl = new FormalList(); }
{
  type=Type() t=<IDENTIFIER> { id=new Identifier(t.image, t.endLine, t.endColumn); } { f = new Formal(type, id, t.endLine, t.endColumn); fl.addElement(f); } ( f=FormalRest() { fl.addElement(f); } )* 
  { return fl; }
}

Formal FormalRest():
{ Token t; Type type; Identifier id; }
{
  <COMMA> type=Type() ( t=<IDENTIFIER> { id=new Identifier(t.image, t.endLine, t.endColumn); } ) { return new Formal(type, id); }
}

/*
 * Type, name and expression syntax follows.
 */
Type Type() :
{ Token t; Type type; }
{
  (
      (
          LOOKAHEAD(2)
          <INT> <LBRACKET> <RBRACKET> { type=new IntArrayType(); }
        | <INT> { type=new IntegerType(); }
      )
    |
      (
          LOOKAHEAD(2)
          <LONG> <LBRACKET> <RBRACKET> { type=new LongArrayType(); }
        | <LONG> { type=new LongType(); }
      )
    | <BOOLEAN> { type=new BooleanType(); }  
    | t=<IDENTIFIER> { type=new IdentifierType(t.image, t.endLine, t.endColumn); }
  )
  { return type; }
}

/*
 * Stmt syntax follows.
 */

Statement Stmt():
{ Token t; Exp e1, e2; Identifier id; Statement rs, s1, s2; VarDecl v; StatementList sl = new StatementList(); VarDeclList vl = new VarDeclList(); }
{
  (
      (
        <LBRACE> 
          ( LOOKAHEAD(2) v=VarDecl() { vl.addElement(v); } )* 
          ( s1=Stmt() { sl.addElement(s1); } )* 
        <RBRACE> 
      )
      { rs = new Block(vl,sl); }
    | /* Extension */
      t=<IF> <LPAREN> e1=Exp() <RPAREN> s1=Stmt() { rs = new If(e1, s1, t.endLine, t.endColumn); }
      [ LOOKAHEAD(1) <ELSE> s2=Stmt() { rs = new IfElse(e1, s1, s2, t.endLine, t.endColumn); } ]
      // <IF> <LPAREN> e1=Exp() <RPAREN> s1=Stmt() <ELSE> s2=Stmt() { rs = new IfElse(e1, s1, s2); } 
    | t=<WHILE> <LPAREN> e1=Exp() <RPAREN> s1=Stmt() { rs = new While(e1, s1, t.endLine, t.endColumn); }
    | <SYSOUT_PRINTLN> <LPAREN> e1=Exp() <RPAREN> <SEMICOLON>  { rs = new Print(e1); }
    | LOOKAHEAD(2)
      ( t = <IDENTIFIER> { id = new Identifier(t.image, t.endLine, t.endColumn); } <ASSIGN> e1=Exp() <SEMICOLON> )  { rs = new Assign(id, e1, t.endLine, t.endColumn); } 
    | ( t = <IDENTIFIER> { id = new Identifier(t.image, t.endLine, t.endColumn); } <LBRACKET> e1=Exp() <RBRACKET> <ASSIGN> e2=Exp() <SEMICOLON> ) { rs = new ArrayAssign(id,e1,e2, t.endLine, t.endColumn); } 
  )
  { return rs; }
}

/*
 * Exp syntax follows.
 */

Exp Exp() : //Or expression with lowest precedence (weakest)
{ Token t; Exp e1, e2; }
{
  e1 = AndExp() [LOOKAHEAD(2) t=<SC_OR> e2 = Exp() { return new Or(e1, e2, t.endLine, t.endColumn); }] { return e1; }
}


Exp AndExp() :
{ Token t; Exp e1, e2; }
{
  e1 = EqExp() [LOOKAHEAD(2) t=<SC_AND> e2 = AndExp() { return new And(e1, e2, t.endLine, t.endColumn); }] { return e1; }

}

Exp EqExp() :
{ Token t; Exp e1, e2; }
{
  e1 = RelExp()
  [   LOOKAHEAD(2) 
      t=<EQ> e2 = EqExp() { return new Equal(e1, e2, t.endLine, t.endColumn); }
    | 
      t=<NE> e2 = EqExp() { return new NotEqual(e1, e2, t.endLine, t.endColumn); }
  ]
  { return e1; }
}


Exp RelExp() :
{ Token t; Exp e1, e2; }
{
  e1 = AddExp() [LOOKAHEAD(2) t=<LT> e2 = RelExp() { return new LessThan(e1, e2, t.endLine, t.endColumn); }] { return e1; }
}

Exp AddExp() :
{ Token t; Exp e1, e2; }
{
  e1 = MultExp()
  [   LOOKAHEAD(2) 
      t=<PLUS> e2 = AddExp() { return new Plus(e1, e2, t.endLine, t.endColumn); }
    | 
      t=<MINUS> e2 = AddExp() { return new Minus(e1, e2, t.endLine, t.endColumn); }
  ]
  { return e1; }
}


Exp MultExp() :
{ Token t; Exp e1, e2; }
{
  e1 = PrimaryExp() [LOOKAHEAD(2) t=<STAR> e2 = MultExp() { return new Times(e1, e2, t.endLine, t.endColumn); }] { return e1; }
}


Exp PrimaryExp():
{ Token t; Exp e;}
{
  (   
      (t = <INTEGER_LITERAL> { e = new IntegerLiteral(Integer.parseInt(t.image), t.endLine, t.endColumn); } ) 
    | (t = <LONG_LITERAL> { e = new LongLiteral(Long.parseLong(t.image.substring(0, t.image.length()-1)), t.endLine, t.endColumn); } ) 
    | <TRUE>  { e = new True(); }
    | <FALSE> { e = new False(); }
    | (t = <IDENTIFIER> { e = new IdentifierExp(t.image, t.endLine, t.endColumn); } )
    | <THIS> { e = new This(); } 
    | LOOKAHEAD(2)
      (
            LOOKAHEAD(<NEW> <INT> <LBRACKET> Exp() <RBRACKET> <LBRACKET>)
            t=<NEW> <INT> <LBRACKET> ( e=Exp() { e = new NewIntArray(e, t.endLine, t.endColumn); } ) <RBRACKET> { return e; }
          | t=<NEW> <INT> <LBRACKET> ( e=Exp() { e = new NewIntArray(e, t.endLine, t.endColumn); } ) <RBRACKET> 

      )
    | LOOKAHEAD(2)
      (
           LOOKAHEAD(<NEW> <LONG> <LBRACKET> Exp() <RBRACKET> <LBRACKET>)
            t=<NEW> <LONG> <LBRACKET> ( e=Exp() { e = new NewLongArray(e, t.endLine, t.endColumn); } ) <RBRACKET> { return e; }
          | t=<NEW> <LONG> <LBRACKET> ( e=Exp() { e = new NewLongArray(e, t.endLine, t.endColumn); } ) <RBRACKET> 

      )
    | {Token obj;} obj=<NEW> ( t = <IDENTIFIER> { e = new NewObject(new Identifier(t.image, t.endLine, t.endColumn), obj.endLine, obj.endColumn); } ) <LPAREN> <RPAREN> 
    | t=<NOT> ( e = Exp() { e = new Not(e, t.endLine, t.endColumn); } ) 
    | <LPAREN> e = Exp() <RPAREN> 
  )
  ( 
    e=ExpPrim(e) 
  )*
  { 
    return e; 
  }
}

Exp ExpPrim(Exp e1):
{ Token t; Exp e2; Identifier id; ExpList el; }
{
    t=<LBRACKET> e2=Exp() <RBRACKET> { return new ArrayLookup(e1, e2, t.endLine, t.endColumn); }
  | LOOKAHEAD(2)
    t=<DOT> <LENGTH> { return new ArrayLength(e1, t.endLine, t.endColumn); }
  | {Token call;} call=<DOT> (t = <IDENTIFIER> { id = new Identifier(t.image, t.endLine, t.endColumn); } ) <LPAREN> el=ExpList() <RPAREN> { return new Call(e1, id, el, call.endLine, call.endColumn); }
}

ExpList ExpList():
{ Exp e; ExpList el = new ExpList(); }
{
	[ e=Exp() { el.addElement(e); } ( e=ExpRest() { el.addElement(e); } )* ]
  { return el; }
}

Exp ExpRest():
{ Exp e; }
{
	"," e=Exp()
  { return e; }
}

