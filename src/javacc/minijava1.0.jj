PARSER_BEGIN(MiniJavaParser)

import java.io.*;
import syntaxtree.*;
import syntaxtree.*;

import java.math.BigInteger;
import java.util.ArrayList;
import java.io.PrintStream;

/**
 * Grammar to parse MiniJava language 
 * @author Christopher Teljstedt and Carl Eriksson 
 */
public class MiniJavaParser
{

public MiniJavaParser (String fileName){
	this(System.in);
    try { ReInit(new FileInputStream(new File(fileName))); }
    catch(Exception e) { e.printStackTrace(); }
}

public static void main(String args[]) {
	MiniJavaParser parser;
	if (args.length == 0) {
		System.out.println("MiniJavac 1.0:  Reading from standard input . . .");
		parser = new MiniJavaParser(System.in);
	} else if (args.length == 1) {
		System.out.println("MiniJavac 1.0:  Reading from file " + args[0] + " . . .");
		try {
			parser = new MiniJavaParser(new java.io.FileInputStream(args[0]));
		} catch (java.io.FileNotFoundException e) {
			System.out.println("MiniJavac 1.0: File " + args[0] + " not found.");
			return;
		}
	} else {
		System.out.println("MiniJavac 1.0:  Usage is one of:");
		System.out.println("         java JavaParser < inputfile");
		System.out.println("OR");
		System.out.println("         java JavaParser inputfile");
		return;
	}
	try {
		parser.Program();
		System.out.println("MiniJavac 1.0: Java program parsed successfully.");
	} catch (ParseException e) {
		System.out.println(e.getMessage());
		System.out.println("MiniJavac 1.0: Encountered errors during parse.");
	}
}
}
PARSER_END(MiniJavaParser)

SKIP: /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN:  /* RESERVED WORDS AND LITERALS */
{
  < BOOLEAN: "boolean" >
| < CLASS: "class" >
| < ELSE: "else" >
| < FALSE: "false" >
| < IF: "if" >
| < INT: "int" >
| < LONG: "long" >
| < NEW: "new" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < STATIC: "static" >
| < THIS: "this" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
| < LENGTH: "length" >
| < STRING: "String" >
| < MAIN: "main" >
| < SYSOUT_PRINTLN : "System.out.println" >
}

TOKEN: /* LITERALS */
{
  < INTEGER_LITERAL:	"0" | (["1"-"9"] (["0"-"9"])*) >
|
  < LONG_LITERAL: "0" | ["1"-"9"](["0"-"9"])* ["l", "L"] >
}

TOKEN: /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < NOT: "!" >
}

TOKEN: /* IDENTIFIERS */
{
  < IDENTIFIER: < LETTER > (< DIGIT >|< LETTER >)* >
| 
  < #LETTER: ["a"-"z", "A"-"Z", "_"] >
| 
  < #DIGIT: "0" | ["1"-"9"](["0"-"9"])* >
}

TOKEN: /* OPERATORS */
{
  < ASSIGN: "=" >
| < LT: "<" >
//| < EQ: "==" > /* Bonus 1p */
//| < LE: "<=" > /* Bonus 1p */
//| < GE: ">=" > /* Bonus 1p */
//| < NE: "!=" > /* Bonus 1p */
//| < SC_OR: "||" > /* Bonus 2p */
| < SC_AND: "&&" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
}



/**********************************************
 * THE MINI JAVA LANGUAGE GRAMMAR STARTS HERE *
 **********************************************/


/*
 * Program structuring syntax follows.
 */

/* Top level production */
Program Program():
{
  MainClass mc;
  ClassDeclList cdl;
}
{
  /* The first class must be the main class */
  mc=MainClass()

  /* Then zero or more other class declarations */
  cdl = ClassDeclList()

  /* And nothing else can be in the file */
  < EOF >
  { return new Program(mc, cdl); }
}

ClassDeclList ClassDeclList():
{ 
  ClassDecl c; 
  ClassDeclList cdl; 
}
{
  (c = ClassDecl() { cdl.addElement(c); })*
  { return cdl.size() > 0 ? cdl : null; }
}

MainClass MainClass():
{
  Token t;
  Identifier id1;
  Identifier id2;
  VarDecl v;
  VarDeclList vdl;
  Statement stmt;
  StatementList sl;
}
{
  <CLASS>
  t = <IDENTIFIER> { id1 = new Identifier(t.image); }
  <LBRACE>
      <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LBRACKET> <RBRACKET> t = <IDENTIFIER> { id2 = new Identifier(t.image); } <RPAREN>
      <LBRACE>
      ( LOOKAHEAD( Type() <IDENTIFIER> ) v = VarDecl() { vdl.addElement(v); } )* 
      ( stmt = Stmt() { sl.addElement(stmt); } )* 
      <RBRACE>
  <RBRACE>
  { return new MainClass(id1, id2, vdl, sl); }
}

ClassDeclSimple ClassDecl():
{
  Token t;
  Id id; 
  VarDecl v;
  VarDeclList vl;
  MethodDecl m;
  MethodDeclList ml;
}
{
  <CLASS>
  t = <IDENTIFIER> { id = new Identifier(t.image); }
  <LBRACE>
      ( LOOKAHEAD(2) v = VarDecl() {vl.addElement(v); } )* 
      ( m = MethodDecl() { ml.addElement(m); } )* 
  <RBRACE>
  { return new ClassDeclSimple(id, vl, ml); }
}

/* Variable declaration */
VarDecl VarDecl() :
{ 
  Token t;
  Type type; 
  Id id;
}
{
  type=Type() ( t = <IDENTIFIER> { id=Identifier(); } ) <SEMICOLON>
  { return new VarDecl(type, id); }
}

MethodDecl MethodDecl():
{
  Token t;
  Type type;
  Identifier id; 
  FormalList fl;
  VarDecl v;
  VarDeclList vl;
  Statement s;
  StatementList sl;
  Exp e;
}
{
  <PUBLIC>
  type = Type()
  ( t = <IDENTIFIER> { id = new Identifier(t.image); } ) 
  fl = FormalList()
  <LBRACE> 
    ( LOOKAHEAD( Type() <IDENTIFIER> ) v = VarDecl() { vl.addElement(v); } )* 
    ( s = Stmt() { sl.addElement(s); } )*  
  <RETURN> e = Exp() <SEMICOLON>
  <RBRACE>
  { return new MethodDecl(type, id, fl, vl, sl, e); }
}

FormalList FormalList():
{
  Token t;
  Type type;
  Identifier id;
  Formal f;
  FormalList fl;
}
{
  <LPAREN> 
          [ 
              (
                type=Type() 
                t=<IDENTIFIER> { id=Identifier(t.image); } 
                { f = new Formal(type, id); fl.addElement(f); }
              ) 
              ( "," f=FormalRest() { fl.addElement(f); } )* 
           ] 
  <RPAREN>
  { return fl; }
}

Formal FormalRest():
{
  Token t;
  Type type;
  Identifier id; 
}
{
  type=Type() ( t=<IDENTIFIER> { id=new Identifier(t.image); } )
  { return new Formal(type, id); }
}

/*
 * Type, name and expression syntax follows.
 */
Type Type() :
{
  Token t;
  Type type; 
}
{
    (
      LOOKAHEAD(2)
      <INT> <LBRACKET> <RBRACKET> { type=new IntArrayType(); }
    |   
      <INT> { type=new IntegerType(); }
    |   
      <BOOLEAN> { type=new BooleanType(); }  
    |   
      t=<IDENTIFIER> { type=new IdentifierType(t.image); }
    )

  { return type; }
}


int Op():
{}
{
  <SC_AND> { return SC_AND; }
|
  <LT> { return LT; }
|
  <PLUS> { return PLUS; }
|
  <MINUS> { return MINUS; }
|
  <STAR> { return STAR; }
}

/*
 * Stmt syntax follows.
 */

Statement Stmt():
{
  Token t;
  Exp e1;
  Exp e2;
  Identifier id;
  Statement rs;
  Statement s1;
  Statement s2;
  StatementList sl;
}
{
  (
      ( <LBRACE> ( s1=Stmt() { sl.addElement(s1); } )* <RBRACE> { rs = new Block(sl); } )
    |
      ( <IF> <LPAREN> e1=Exp() <RPAREN> s1=Stmt() <ELSE> s2=Stmt() { rs = new If(e1, s1, s2); } )
    |
      ( <WHILE> <LPAREN> e1=Exp() <RPAREN> s1=Stmt() { rs = new While(e1, s1); } )
    |
      ( <SYSOUT_PRINTLN> <LPAREN> e1=Exp() <RPAREN> <SEMICOLON> { rs = new Print(e1); } )
    |
      ( LOOKAHEAD(2)
      ( t = <IDENTIFIER> { id = new Identifier(t.image); } ) <ASSIGN> e1=Exp() <SEMICOLON>  { rs = new Assign(id,e1); } )
    |
      ( LOOKAHEAD(2)
      ( t = <IDENTIFIER> { id = new Identifier(t.image); } ) <LBRACKET> e1=Exp() <RBRACKET> <ASSIGN> e2=Exp() <SEMICOLON> { rs = new ArrayAssign(id,e1,e2); } )
  )
  { return rs; }
}


/*
 * Exp syntax follows.
 */

Exp Exp():
{
  Token t;
  Exp e;
}
{
  (
      <INTEGER_LITERAL> { e = new IntegerLiteral(); } 
    |
      <TRUE>  { e = new True(); }
    |
      <FALSE> { e = new False(); }
    |
      <IDENTIFIER> { e = new IdentifierExp(); }
    |
      <THIS> { e = new This(); } 
    |
      LOOKAHEAD(2)
      <NEW> <INT> <LBRACKET> ( e=Exp() { e = new NewArray(e); } ) <RBRACKET> 
    |
      LOOKAHEAD(2)
      <NEW> ( t = <IDENTIFIER> { e = new NewObject(new IdentifierExp(t.image)); } ) <LPAREN> <RPAREN> 
    |
      <NOT> ( e = Exp() { e = new Not(e); } ) 
    |
      <LPAREN> e = Exp() <RPAREN> 
  )
  ( LOOKAHEAD(2) e=ExpPrim(e) )*
  { return e; }
}

Exp ExpPrim(Exp e1):
{
  Token t;
  Exp e2;
  int op;
  Identifier id;
  ExpList el;
}
{
    LOOKAHEAD(2)
    op=Op() e2=Exp()
    {
      switch (op) {
        case SC_AND: return new And(e1, e2);
        case LT: return new LessThan(e1, e2);
        case PLUS: return new Plus(e1, e2); 
        case MINUS: return new Minus(e1, e2); 
        case STAR: return new Times(e1, e2);
      }
    }
  | 
    <LBRACKET> e2=Exp() <RBRACKET> 
    { return new ArrayLookup(e1, e2); }
  |
    LOOKAHEAD(2)
    <DOT> <LENGTH> 
    { return new ArrayLength(e1); }
  |
    LOOKAHEAD(2)
    <DOT> (t = <IDENTIFIER> { id = new IdentifierExp(t.image); } ) el=ExpList()
    { return new Call(e1, id, el); }
}

ExpList ExpList():
{
  Exp e;
  ExpList el;
}
{
	<LPAREN> [ e=Exp() { el.addElement(e); } ( e=ExpRest() { el.addElement(e); } )* ] <RPAREN>
  { return el; }
}

Exp ExpRest():
{
  Exp e;
}
{
	"," e=Exp()
  { return t; }
}

