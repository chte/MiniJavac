PARSER_BEGIN(MiniJavaParser)

import java.io.*;
import syntaxtree.*;
import symboltree.*;

import java.math.BigInteger;
import java.util.ArrayList;
import java.io.PrintStream;

/**
 * Grammar to parse MiniJava language 
 * @author Christopher Teljstedt and Carl Eriksson 
 */
public class MiniJavaParser
{

public final static boolean VERBOSE = true;

public MiniJavaParser (String fileName){
	this(System.in);
    try { ReInit(new FileInputStream(new File(fileName))); }
    catch(Exception e) { e.printStackTrace(); }
}

public static void main(String args[]) {
	MiniJavaParser parser;
  Program program;
  SyntaxTreePrinter stp;
  SymbolTableBuilder stb;
  TypeDepthFirstVisitor tdfv;

	if (args.length == 0) {
		System.out.println("MiniJavac 1.0:  Reading from standard input . . .");
		parser = new MiniJavaParser(System.in);
	} else if (args.length == 1) {
		System.out.println("MiniJavac 1.0:  Reading from file " + args[0] + " . . .");
		try {
			parser = new MiniJavaParser(new java.io.FileInputStream(args[0]));
		} catch (java.io.FileNotFoundException e) {
			System.out.println("MiniJavac 1.0: File " + args[0] + " not found.");
			return;
		}
  } else if (args.length == 2){
    System.out.println("MiniJavac 1.0:  Reading from file " + args[1] + " . . .");
    try {
      parser = new MiniJavaParser(new java.io.FileInputStream(args[1]));
    } catch (java.io.FileNotFoundException e) {
      System.out.println("MiniJavac 1.0: File " + args[1] + " not found.");
      return;
    }  
	} else {
		System.out.println("MiniJavac 1.0:  Usage is one of:");
		System.out.println("         java JavaParser < inputfile");
		System.out.println("OR");
		System.out.println("         java JavaParser inputfile");
		return;
	}
	try {
		program = parser.Program();

    
    // VERBOSE: Print abstract syntax tree 
    if(VERBOSE) {
      stp = new SyntaxTreePrinter(System.out);
      stp.visit(program);
      System.out.println();
    }
   
    //Symbol table
    stb = new SymbolTableBuilder();
    stb.visit(program);
    
    // VERBOSE: Output symbol table
    if(VERBOSE) {
      SymbolTable st = stb.scopeLookupTable.get(program);
      System.out.println(st.toString(0));
    }
    
    //Type checking.
    tdfv = new TypeDepthFirstVisitor();
    tdfv.scopeLookupTable = stb.scopeLookupTable;
    tdfv.visit(program);


		System.out.println("MiniJavac 1.0: Java program parsed successfully.");
	} catch (ParseException e) {
		System.out.println(e.getMessage());
		System.out.println("MiniJavac 1.0: Encountered errors during parse.");
	}
}
}
PARSER_END(MiniJavaParser)

SKIP: /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN:  /* RESERVED WORDS AND LITERALS */
{
  < BOOLEAN: "boolean" >
| < CLASS: "class" >
| < ELSE: "else" >
| < FALSE: "false" >
| < IF: "if" >
| < INT: "int" >
| < LONG: "long" >
| < NEW: "new" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < STATIC: "static" >
| < THIS: "this" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
| < LENGTH: "length" >
| < STRING: "String" >
| < MAIN: "main" >
| < SYSOUT_PRINTLN : "System.out.println" >
}

TOKEN: /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < NOT: "!" >
}


TOKEN: /* LITERALS */
{
  < INTEGER_LITERAL: ( ["0"] | ["1"-"9"](["0"-"9"])*) >
//|
//  < LONG_LITERAL: "0" | ["1"-"9"](["0"-"9"])* ["l", "L"] >
}


TOKEN: /* IDENTIFIER LITTERAL */
{
  < IDENTIFIER: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "0"-"9", "_"])* >
}

TOKEN: /* OPERATORS */
{
  < ASSIGN: "=" >
| < LT: "<" >
// | < GT: ">" >
// | < EQ: "==" > /* Bonus 1p */
// | < LE: "<=" > /* Bonus 1p */
// | < GE: ">=" > /* Bonus 1p */
// | < NE: "!=" > /* Bonus 1p */
// | < SC_OR: "||" > /* Bonus 2p */
| < SC_AND: "&&" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
}

/**********************************************
 * THE MINI JAVA LANGUAGE GRAMMAR STARTS HERE *
 **********************************************/
/*
 * Program structuring syntax follows.
 */

/* Top level production */
Program Program():
{ MainClass mc; ClassDeclList cdl; }
{
  /* The first class must be the main class */
  mc=MainClass()

  /* Then zero or more other class declarations */
  cdl = ClassDeclList() 

  /* And nothing else can be in the file */
  < EOF >
  { return new Program(mc, cdl); }
}

ClassDeclList ClassDeclList():
{ ClassDecl c; ClassDeclList cdl = new ClassDeclList(); }
{
  (c = ClassDecl() { cdl.addElement(c); })*
  { return cdl; }
}

MainClass MainClass():
{ Token t; Identifier id1, id2; VarDecl v; Statement stmt; VarDeclList vdl = new VarDeclList(); StatementList sl = new StatementList(); }
{
  <CLASS>
  t = <IDENTIFIER> { id1 = new Identifier(t.image); }
  <LBRACE>
      <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LBRACKET> <RBRACKET> t = <IDENTIFIER> { id2 = new Identifier(t.image); } <RPAREN>
      <LBRACE> //Block
      ( LOOKAHEAD( Type() <IDENTIFIER> ) v = VarDecl() { vdl.addElement(v); } )* 
      ( stmt = Stmt() { sl.addElement(stmt); } )* 
      <RBRACE>
  <RBRACE>
  { return new MainClass(id1, id2, vdl, sl); }
}

ClassDeclSimple ClassDecl():
{
  Token t; Identifier id; VarDecl v; MethodDecl m; VarDeclList vl = new VarDeclList(); MethodDeclList ml = new MethodDeclList();
}
{
  <CLASS> t = <IDENTIFIER> { id = new Identifier(t.image); }
  <LBRACE> //Block
       ( LOOKAHEAD(2) v = VarDecl() {vl.addElement(v); } )* ( m = MethodDecl() { ml.addElement(m); } )* 
  <RBRACE>
  { return new ClassDeclSimple(id, vl, ml); }
}

/* Variable declaration */
VarDecl VarDecl() :
{ Token t; Type type; Identifier id; }
{
  type=Type() ( t = <IDENTIFIER> { id=new Identifier(t.image); } ) <SEMICOLON>  { return new VarDecl(type, id); }
}

MethodDecl MethodDecl():
{ Exp e; Token t; Type type; Identifier id;  VarDecl v; Statement s; FormalList fl = new FormalList(); VarDeclList vl = new VarDeclList(); StatementList sl = new StatementList(); }
{
  <PUBLIC> type = Type() ( t = <IDENTIFIER> { id = new Identifier(t.image); } ) <LPAREN> [ fl = FormalList() ] <RPAREN>
  <LBRACE> 
    ( LOOKAHEAD(2) v = VarDecl() { vl.addElement(v); } )* 
    ( s = Stmt() { sl.addElement(s); } )*  
    <RETURN> e = Exp() <SEMICOLON>
  <RBRACE>
  { return new MethodDecl(type, id, fl, vl, sl, e); }
}

FormalList FormalList():
{ Token t; Type type; Identifier id; Formal f; FormalList fl = new FormalList(); }
{
  type=Type() t=<IDENTIFIER> { id=new Identifier(t.image); } { f = new Formal(type, id); fl.addElement(f); } ( f=FormalRest() { fl.addElement(f); } )* 
  { return fl; }
}

Formal FormalRest():
{ Token t; Type type; Identifier id; }
{
  <COMMA> type=Type() ( t=<IDENTIFIER> { id=new Identifier(t.image); } ) { return new Formal(type, id); }
}

/*
 * Type, name and expression syntax follows.
 */
Type Type() :
{ Token t; Type type; }
{
  (
      LOOKAHEAD(2)
      <INT> <LBRACKET> <RBRACKET> { type=new IntArrayType(); }
    | <INT> { type=new IntegerType(); }
    | <BOOLEAN> { type=new BooleanType(); }  
    | t=<IDENTIFIER> { type=new IdentifierType(t.image); }
  )
  { return type; }
}

/*
 * Stmt syntax follows.
 */

Statement Stmt():
{ Token t; Exp e1, e2; Identifier id; Statement rs, s1, s2; StatementList sl = new StatementList(); }
{
  (
      <LBRACE> ( s1=Stmt() { sl.addElement(s1); } )* <RBRACE> { rs = new Block(sl); }
    | // /* Extension */
      // <IF> <LPAREN> e1=Exp() <RPAREN> s1=Stmt() { rs = new If(e1, s1); }
      // [ LOOKAHEAD(1) <ELSE> s2=Stmt() { rs = new IfElse(e1, s1, s2); } ]
      <IF> <LPAREN> e1=Exp() <RPAREN> s1=Stmt() <ELSE> s2=Stmt() { rs = new IfElse(e1, s1, s2); } 
    | <WHILE> <LPAREN> e1=Exp() <RPAREN> s1=Stmt() { rs = new While(e1, s1); }
    | <SYSOUT_PRINTLN> <LPAREN> e1=Exp() <RPAREN> <SEMICOLON>  { rs = new Print(e1); }
    | LOOKAHEAD(2)
      t = <IDENTIFIER> { id = new Identifier(t.image); } <ASSIGN> e1=Exp() <SEMICOLON>  { rs = new Assign(id,e1); } 
    | t = <IDENTIFIER> { id = new Identifier(t.image); } <LBRACKET> e1=Exp() <RBRACKET> <ASSIGN> e2=Exp() <SEMICOLON> { rs = new ArrayAssign(id,e1,e2); } 
  )
  { return rs; }
}

/*
 * Exp syntax follows.
 */

Exp Exp() : //Or expression with lowest precedence (weakest)
{ Exp e1, e2; }
{
  e1 = RelExp() [LOOKAHEAD(2) <SC_AND> e2 = Exp() { return new Or(e1, e2); }] { return e1; }
}

Exp RelExp() :
{ Exp e1, e2; }
{
  e1 = AddExp() [LOOKAHEAD(2) <LT> e2 = RelExp() { return new LessThan(e1, e2); }] { return e1; }
}

Exp AddExp() :
{ Exp e1, e2; }
{
  e1 = MultExp()
  [   LOOKAHEAD(2) 
      <PLUS> e2 = AddExp() { return new Plus(e1, e2); }
    | 
      <MINUS> e2 = AddExp() { return new Minus(e1, e2); }
  ]
  { return e1; }
}

Exp MultExp() :
{ Exp e1, e2; }
{
  e1 = PrimaryExp() [LOOKAHEAD(2) <STAR> e2 = MultExp() { return new Times(e1, e2); }] { return e1; }
}


Exp PrimaryExp():
{ Token t; Exp e; }
{
  (
      (t = <INTEGER_LITERAL> { e = new IntegerLiteral(Integer.parseInt(t.image)); } ) 
    | <TRUE>  { e = new True(); }
    | <FALSE> { e = new False(); }
    | (t = <IDENTIFIER> { e = new IdentifierExp(t.image); } )
    | <THIS> { e = new This(); } 
    |  LOOKAHEAD(2)
      <NEW> <INT> <LBRACKET> ( e=Exp() { e = new NewIntArray(e); } ) <RBRACKET> 
    | <NEW> ( t = <IDENTIFIER> { e = new NewObject(new Identifier(t.image)); } ) <LPAREN> <RPAREN> 
    | <NOT> ( e = Exp() { e = new Not(e); } ) 
    | <LPAREN> e = Exp() <RPAREN> 
  )
  ( LOOKAHEAD(2) e=ExpPrim(e) )*
  { return e; }
}

Exp ExpPrim(Exp e1):
{ Token t; Exp e2; Identifier id; ExpList el; }
{
    <LBRACKET> e2=Exp() <RBRACKET> { return new ArrayLookup(e1, e2); }
  | LOOKAHEAD(2)
    <DOT> <LENGTH> { return new ArrayLength(e1); }
  | <DOT> (t = <IDENTIFIER> { id = new Identifier(t.image); } ) <LPAREN> el=ExpList() <RPAREN> { return new Call(e1, id, el); }
}

ExpList ExpList():
{ Exp e; ExpList el = new ExpList(); }
{
	[ e=Exp() { el.addElement(e); } ( e=ExpRest() { el.addElement(e); } )* ]
  { return el; }
}

Exp ExpRest():
{ Exp e; }
{
	"," e=Exp()
  { return e; }
}

